<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[JMeter性能测试3.0时代之-多维度的图形化HTML报告]]></title>
      <url>http://walbx.github.io/2016/07/17/JMeter%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%953-0%E6%97%B6%E4%BB%A3%E4%B9%8B-%E5%A4%9A%E7%BB%B4%E5%BA%A6%E7%9A%84%E5%9B%BE%E5%BD%A2%E5%8C%96HTML%E6%8A%A5%E5%91%8A/</url>
      <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/large/9bd9d3e2gw1f5x232chyaj20b5096q3q.jpg" alt=""></p>
<blockquote>
<p>在上一篇博客<a href="http://www.jianshu.com/p/31776d20c22c" target="_blank" rel="external">JMeter性能测试3.0时代之-全新JMeter插件管理</a>中我说会写真正的JMeter 3.0新特性，时隔两周，总算在这个周末，暂停其他安排，来继续这个未完成的系列。<br>本文主要介绍JMeter3.0引入的新特性：<a href="https://jmeter.apache.org/usermanual/generating-dashboard.html" target="_blank" rel="external">Dashboard Report</a>，图形化的HTML格式多维度测试报告。借助这个特性，可以很大程度上降低我们搭建基于JMeter的性能测试平台时，在结果展示上的难度，将更多的经历放在后端的平台功能而不是去临时学习前端图表库。</p>
</blockquote>
<a id="more"></a>
<h2 id="一-为什么谈这个新特性"><a href="#一-为什么谈这个新特性" class="headerlink" title="一.为什么谈这个新特性"></a>一.为什么谈这个新特性</h2><p>在JMeter3.0之前，官方只提供在工具的UI上对测试结果部分维度的图形化展示，这对我带来了两方面的困扰：</p>
<ol>
<li>在实际使用中，在平台中集成JMeter后需要页面展示TPS曲线，平均响应时间曲线等图表时，需要我们手动操刀摆弄如Hightcharts/Echarts等前端图表库。</li>
<li>要查看历史的测试结果，需要启动JMeter的图形化界面，导入保存的CSV结果，过程繁琐，并且当结果集较大时，JMeter需要耗费相当多的时间在界面上展示图形化报告。</li>
</ol>
<p>本文讨论的新特性为这两个问题带来了较好的解决办法：</p>
<ul>
<li>新特性良好的实现了结果数据可视化，生成的报告是HTML页面形式，并且包含大多数实际测试中关心的度量维度的，可以便捷地嵌入到平台，从浏览器来查看每次测试运行的。</li>
<li>只要保留生成的HTML页面，后期要查看该次测试的结果，只需要在浏览器打开即可，方便快捷。</li>
</ul>
<h2 id="二-新特性简介"><a href="#二-新特性简介" class="headerlink" title="二.新特性简介"></a>二.新特性简介</h2><p>JMeter3.0提供一个用于生成<strong>HTML页面格式图形化报告</strong>的扩展模块。该模块支持通过两种方式生成多维度图形化测试报告：</p>
<ol>
<li>在JMeter性能测试结束时，自动生成本次测试的HTML图形化报告</li>
<li>使用一个已有的结果文件(如CSV文件)来生成该次结果的HTML图形化报告</li>
</ol>
<p><strong>其默认提供的度量维度包括：</strong></p>
<ol>
<li>APDEX(Application Performance Index)指数</li>
<li>聚合报告<ul>
<li>类似于UI上的<em>Aggregate Report</em></li>
</ul>
</li>
<li>Errors报告<ul>
<li>展示不同错误类型的数量以及百分比</li>
</ul>
</li>
<li>响应时间变化曲线<ul>
<li>展示平均响应时间随时间变化情况</li>
<li>类似于JMeter Plugins在UI上的<em>jp@gc - Response Times Over Time</em></li>
</ul>
</li>
<li>数据吞吐量时间曲线<ul>
<li>展示每秒数据吞吐量随时间变化的情况</li>
<li>类似于JMeter Plugins在UI上的<em>jp@gc - Bytes Throughput Over Time</em></li>
</ul>
</li>
<li>Latency time变化曲线<ul>
<li>展示Latency time随时间变化的情况</li>
<li>类似于JMeter Plugins在UI上的<em>jp@gc - Response Latencies Over Time</em></li>
</ul>
</li>
<li>每秒点击数曲线<ul>
<li>类似于JMeter Plugins在UI上的<em>jp@gc - Hits per Second</em></li>
</ul>
</li>
<li>HTTP状态码时间分布曲线<ul>
<li>展示响应状态码随时间的分布情况</li>
<li>类似于JMeter Plugins在UI上的<em>jp@gc - Response Codes per Second</em></li>
</ul>
</li>
<li>事务吞吐量时间曲线(TPS)<ul>
<li>展示每秒处理的事务数随时间变化情况</li>
<li>类似于JMeter Plugins在UI上的<em>jp@gc - Transactions per Second</em></li>
</ul>
</li>
<li>平均响应时间与每秒请求数的关系图<ul>
<li>展示平均响应时间与每秒请求数(可以理解为QPS)的关系</li>
</ul>
</li>
<li>Latency time与每秒请求数的关系图<ul>
<li>展示Latency time与每秒请求数的关系</li>
</ul>
</li>
<li>响应时间百分位图<ul>
<li>响应时间的百分位分布图</li>
</ul>
</li>
<li>活动线程数变化曲线<ul>
<li>展示测试过程中活动线程数随时间变化情况</li>
</ul>
</li>
<li>平均响应时间与线程数的关系图<ul>
<li>展示平均响应时间与线程数的关系</li>
<li>类似于JMeter Plugins在UI上的<em>jp@gc - Response Times vs Threads</em></li>
</ul>
</li>
<li>柱状响应时间分布图<ul>
<li>展示落在各个平均响应时间区间的请求数情况</li>
</ul>
</li>
</ol>
<p><em>注1：Latency time没有翻译成中文，这里对其计算方式做注解：</em><br>    <em>Latency time = 接收到响应的第一个字节的时间点 - 请求开始发送的时间点</em></p>
<blockquote>
<p> <em>from just before sending the request to just after the first response has been received</em><br>– <a href="http://jmeter.apache.org/usermanual/glossary.html" target="_blank" rel="external">Apache JMeter Glossary</a></p>
</blockquote>
<p>  <em>响应时间(JMeter术语中的Elapsed time) = 接收完所有响应内容的时间点 - 请求开始发送的时间点</em></p>
<blockquote>
<p><em>from just before sending the request to just after the last response has been received</em><br>– <a href="http://jmeter.apache.org/usermanual/glossary.html" target="_blank" rel="external">Apache JMeter Glossary</a></p>
</blockquote>
<p><em>注2：Apdex 标准从用户的角度出发，将对应用响应时间的表现，转为用户对于应用性能的可量化为范围为 0-1 的满意度评价。。</em></p>
<blockquote>
<p><strong>Apdex (Application Performance Index)</strong> is an open standard developed by an alliance of companies. It defines a standard method for reporting and comparing the performance of software applications in computing.<br>– <a href="https://en.wikipedia.org/wiki/Apdex" target="_blank" rel="external">wikipedia</a></p>
</blockquote>
<h2 id="三-快速入门"><a href="#三-快速入门" class="headerlink" title="三.快速入门"></a>三.快速入门</h2><h3 id="1-确认基本配置"><a href="#1-确认基本配置" class="headerlink" title="1.确认基本配置"></a>1.确认基本配置</h3><ul>
<li><p>在jmeter.properties或者user.properties确认如下配置项：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">jmeter.save.saveservice.bytes = true</span><br><span class="line">jmeter.save.saveservice.label = true</span><br><span class="line">jmeter.save.saveservice.latency = true</span><br><span class="line">jmeter.save.saveservice.response_code = true</span><br><span class="line">jmeter.save.saveservice.response_message = true</span><br><span class="line">jmeter.save.saveservice.successful = true</span><br><span class="line">jmeter.save.saveservice.thread_counts = true</span><br><span class="line">jmeter.save.saveservice.thread_name = true</span><br><span class="line">jmeter.save.saveservice.time = true</span><br><span class="line"># the timestamp format must include the time and should include the date.</span><br><span class="line"># For example the default, which is milliseconds since the epoch: </span><br><span class="line">jmeter.save.saveservice.timestamp_format = ms</span><br><span class="line"># Or the following would also be suitable</span><br><span class="line">jmeter.save.saveservice.timestamp_format = yyyy/MM/dd HH:mm:ss</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果希望在Errors报告中展示更详细数据，需要确保如下配置</p>
<ul>
<li><code>jmeter.save.saveservice.assertion_results_failure_message = true</code></li>
<li>如果使用了事务控制器(Transaction Controller)，确认<em>Generate parent sample</em>为未勾选状态</li>
</ul>
</li>
</ul>
<h3 id="2-生成报告"><a href="#2-生成报告" class="headerlink" title="2.生成报告"></a>2.生成报告</h3><p>a. 在压力测试结束时报告</p>
<ul>
<li>基本命令格式：<br><code>jmeter -n -t &lt;test JMX file&gt; -l &lt;test log file&gt; -e -o &lt;Path to output folder&gt;</code></li>
<li>样例：<br><code>jmeter -n -t F:\PerformanceTest\TestCase\script\getToken.jmx -l testLogFile -e -o ./output</code></li>
</ul>
<p>b. 使用已有的压力测试CSV日志文件生成报告</p>
<ul>
<li>基本命令格式：<br><code>jmeter -g &lt;log file&gt; -o &lt;Path to output folder&gt;</code></li>
<li>样例：<br><code>jmeter -g D:\apache-jmeter-3.0\bin\testLogFile -o ./output</code></li>
</ul>
<p>两个样例都会在\apache-jmeter-3.0\bin\output目录下产生如下文件(夹):<br><img src="http://ww3.sinaimg.cn/large/9bd9d3e2gw1f5x043a8xuj20if03vdgd.jpg" alt=""></p>
<p>用浏览器打开index.html文件，即可查看各种图形化报告:<br><img src="http://ww4.sinaimg.cn/large/9bd9d3e2gw1f5x04glvcqj20ki0cm3zr.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/9bd9d3e2gw1f5x0ao5dkjj212u0fqjvr.jpg" alt=""></p>
<h2 id="四-自定义配置"><a href="#四-自定义配置" class="headerlink" title="四.自定义配置"></a>四.自定义配置</h2><p>JMeter3.0在bin目录新增了<code>reportgenerator.properties</code>文件保存了所有关于图形化HTML报告生成模块的默认配置，要变更配置，建议不要直接编辑该文件，而是推荐在<code>user.properties</code>中去配置和覆盖。</p>
<h3 id="1-总体配置"><a href="#1-总体配置" class="headerlink" title="1.总体配置"></a>1.总体配置</h3><p>总体配置都是以<code>jmeter.reportgenerator.</code>为前缀。如：jmeter.reportgenerator.overall_granularity=60000</p>
<ul>
<li><p><code>overall_granularity</code>：定义采样点粒度，默认为60000ms，通常在稳定性以外的测试中，我们可能需要定义更细的粒度，比如1000ms，我们可以在<code>user.properties</code>文件末尾添加如下配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Change this parameter if you want to change the granularity of over time graphs.</span><br><span class="line">jmeter.reportgenerator.overall_granularity=6000</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>report_title</code>:定义报告的标题，我们可能需要将标题定义为实际测试项名称</p>
</li>
<li><code>apdex_satisfied_threshold</code>：定义Apdex评估中<strong>满意</strong>的阈值(单位ms)</li>
<li><code>apdex_tolerated_threshold</code>: 定义Apdex评估中<strong>可容忍</strong>的阈值<br><code>Apdext = (Satisfied Count + Tolerating Count / 2) / Total Samples</code></li>
</ul>
<p>另外，在<code>jmeter.properties</code>中，有关于集合报告中的三个百分位的默认值：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aggregate_rpt_pct1 : Defaults to 90</span><br><span class="line">aggregate_rpt_pct2 : Defaults to 95</span><br><span class="line">aggregate_rpt_pct3 : Defaults to 99</span><br></pre></td></tr></table></figure></p>
<p>可以在<code>user.properties</code>中对其进行覆盖，如：<code>aggregate_rpt_pct1 = 70</code>，效果如下：<br><img src="http://ww3.sinaimg.cn/large/9bd9d3e2gw1f5x04h6f3dj20bl06cq3b.jpg" alt=""></p>
<h3 id="2-图表配置"><a href="#2-图表配置" class="headerlink" title="2.图表配置"></a>2.图表配置</h3><p>每个图表配置都是以<code>jmeter.reportgenerator.graph.&lt;图表名称&gt;.</code>为前缀。</p>
<ul>
<li><code>classname</code> 图表的实现类，如果有自己定制的实现，将该配置的值写为自定义实现类的类名</li>
<li><code>title</code> 图标标题，比如要汉化的时候，在这里配置中文标题</li>
<li><code>property.set_granularity</code> 设置图标的采样点粒度，不配置时默认使用总体配置中的粒度设置</li>
</ul>
<h3 id="3-输出配置"><a href="#3-输出配置" class="headerlink" title="3.输出配置"></a>3.输出配置</h3><p>输出配置都以<code>jmeter.reportgenerator.exporter</code>为前缀。</p>
<ul>
<li><code>property.output_dir</code> 配置默认的报告输出路径。在命令行可以用-o选项来设置特定的路径覆盖该配置。</li>
<li><code>html.series_filter</code> 用于过滤展示内容。如在user.properties添加如下配置：<br><code>jmeter.reportgenerator.exporter.html.series_filter=(^Login)(-success|-failure)?</code><br>则最后的报告只展示名为Login这个取样器的数据。该配置包含两部分，<code>(-success|-failure)?</code>是<code>Transactions per second</code>图表所依赖的配置。前面部分接受一个正则表达式用来过滤。</li>
</ul>
<h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五.总结"></a>五.总结</h2><p>本次介绍的<code>Dashboard Report</code>特性本质上是Apache JMeter对于测试结果数据可视化方式的顺应时代的更新，虽然算是姗姗来迟，虽然并不酷炫，但至少，对于要需要基于它来执行性能测试的人来说，仍然是一个福音。最后，感谢Apache JMeter项目的各位贡献者对它的持续更新。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li><a href="http://jmeter.apache.org/usermanual/generating-dashboard.html" target="_blank" rel="external">Apache JMeter Dashboard Report</a></li>
<li><a href="http://jmeter.apache.org/usermanual/glossary.html" target="_blank" rel="external">Apache JMeter Glossary</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Dubbo高级特性实践-泛化调用]]></title>
      <url>http://walbx.github.io/2016/07/10/Dubbo%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E5%AE%9E%E8%B7%B5-%E6%B3%9B%E5%8C%96%E8%B0%83%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>当后端Java服务用<a href="http://dubbo.io/" target="_blank" rel="external">Dubbo</a>协议作为RPC方案的基础，但部分消费方是前端Restful的PHP服务，不能直接调用，于是在中间架设了Router服务提供统一的基于HTTP的后端调用入口。<br>而Router调用后端Java服务就应用了Dubbo的高级特性–<strong>泛化调用</strong></p>
<ul>
<li>直接消费方(Router服务)不需要引入接口jar包</li>
<li>通过GenericService接口来处理所有服务请求</li>
<li>以PHP到Router的request body中的方法名和方法参数作为Router远程调用后端Java服务的入参，最后将远程调用的result返回给PHP端</li>
</ul>
<p>本文将用一个小Demo来演示上面所述的<strong>泛化调用</strong>应用场景</p>
<a id="more"></a>
<h2 id="零-Dubbo简介"><a href="#零-Dubbo简介" class="headerlink" title="零.Dubbo简介"></a>零.Dubbo简介</h2><blockquote>
<p><em>DUBBO是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，是阿里巴巴SOA服务化治理方案的核心框架，每天为2,000+个服务提供3,000,000,000+次访问量支持，并被广泛应用于阿里巴巴集团的各成员站点。</em><br>– Dubbo官方描述</p>
<h3 id="Dubbo能做什么："><a href="#Dubbo能做什么：" class="headerlink" title="Dubbo能做什么："></a><em>Dubbo能做什么：</em></h3><ul>
<li>透明化的远程方法调用 <ul>
<li>就像调用本地方法一样调用远程方法</li>
<li>只需简单配置，没有任何API侵入。 </li>
</ul>
</li>
<li>软负载均衡及容错机制<ul>
<li>可在内网替代F5等硬件负载均衡器</li>
</ul>
</li>
<li>服务自动注册与发现<ul>
<li>不再需要写死服务提供方地址，注册中心基于接口名查询服务提 供者的IP地址，并且能够平滑添加或删除服务提供者 </li>
</ul>
</li>
</ul>
<p>– 《Dubbo功能介绍》(<em>官方资料</em>)</p>
</blockquote>
<p><em>注：Dubbo的基本使用介绍不在本文范畴，如有需要请自行参考<a href="http://dubbo.io/" target="_blank" rel="external">官方资料</a></em></p>
<blockquote>
<p><em>泛接口调用方式主要用于客户端没有API接口及模型类元的情况，参数及返回值中的所有POJO均用Map表示，通常用于框架集成，比如：实现一个通用的服务测试框架，可通过GenericService调用所有服务实现。</em><br>– Dubbo用户指南</p>
</blockquote>
<h2 id="一-后端API"><a href="#一-后端API" class="headerlink" title="一.后端API"></a>一.后端API</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserInfoService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">getUser</span><span class="params">(String id)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String&gt;[] getUsers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二-Router端dubbo配置"><a href="#二-Router端dubbo配置" class="headerlink" title="二.Router端dubbo配置"></a>二.Router端dubbo配置</h2><p><code>dubboconf.properties:</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">application.name=router</span><br><span class="line">registry.address=zookeeper://address1?buckup=address2,address3</span><br></pre></td></tr></table></figure></p>
<h2 id="三-前端服务post到Router的Request-Body示例："><a href="#三-前端服务post到Router的Request-Body示例：" class="headerlink" title="三.前端服务post到Router的Request Body示例："></a>三.前端服务post到Router的Request Body示例：</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"interfaceName"</span>: <span class="string">"foo"</span>, </span><br><span class="line">    <span class="attr">"methodName"</span>: <span class="string">"bar"</span>, </span><br><span class="line">    <span class="attr">"methodParams"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"id"</span>: <span class="string">"xxx"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四-处理前端参数用的Dto"><a href="#四-处理前端参数用的Dto" class="headerlink" title="四.处理前端参数用的Dto"></a>四.处理前端参数用的Dto</h2><p><code>RequestDto.java:</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Luo</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestDto</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line">    <span class="keyword">private</span> String methodName</span><br><span class="line">    <span class="keyword">private</span> Map[] methodParams;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInterfaceName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> interfaceName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInterfaceName</span><span class="params">(String interfaceName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.interfaceName =  interfaceName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMethodName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> methodName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMethodName</span><span class="params">(String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.methodName = methodName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Map[] getMethodParams() &#123;</span><br><span class="line">        <span class="keyword">return</span> methodParams;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMethodParam</span><span class="params">(Map[] methodParams)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.methodParams = methodParams;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="五-Router服务入口"><a href="#五-Router服务入口" class="headerlink" title="五.Router服务入口"></a>五.Router服务入口</h2><p><code>RouterController.java:</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Luo</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">        <span class="meta">@RequestMapping</span>(value = <span class="string">"/router/"</span>, method = RequestMethod.POST)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getUser</span><span class="params">(@ModelAttribute RequestDto dto)</span> </span>&#123;</span><br><span class="line">            Map map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            map.put(<span class="string">"ParamType"</span>, <span class="string">"java.lang.String"</span>);  <span class="comment">//后端接口参数类型</span></span><br><span class="line">            map.put(<span class="string">"Object"</span>, dto.getMethodParams()[<span class="number">0</span>].get(<span class="string">"id"</span>));  <span class="comment">//用以调用后端接口的实参</span></span><br><span class="line"></span><br><span class="line">            List&lt;Map&lt;String, Object&gt;&gt; paramInfos= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            paramInfos.add(map);</span><br><span class="line"></span><br><span class="line">            DubboServiceFactory dubbo = DubboServiceFactory.getInstance();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> dubbo.genericInvoke(dto.getInterfaceName(), dto.getMethodName(), paramInfos);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>注：本文旨在演示泛化调用的一种应用方式，为简明起见，代码中直接从dto中获取了指定参数，而并没有完整实现其路由功能，望见谅。</em></p>
<h2 id="六-通过GenericService进行泛化调用"><a href="#六-通过GenericService进行泛化调用" class="headerlink" title="六.通过GenericService进行泛化调用"></a>六.通过GenericService进行泛化调用</h2><p><code>DubboServiceFactory.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> local.demo.genericservice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ApplicationConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ReferenceConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.RegistryConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.utils.ReferenceConfigCache;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.rpc.service.GenericService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Luo</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboServiceFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationConfig application;</span><br><span class="line">    <span class="keyword">private</span> RegistryConfig registry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> DubboServiceFactory INSTANCE = <span class="keyword">new</span> DubboServiceFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DubboServiceFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        ClassLoader loader = DubboServiceFactory.class.getClassLoader();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            prop.load(loader.getResourceAsStream(<span class="string">"dubboconf.properties"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ApplicationConfig applicationConfig = <span class="keyword">new</span> ApplicationConfig();</span><br><span class="line">        applicationConfig.setName(prop.getProperty(<span class="string">"application.name"</span>)); </span><br><span class="line">        <span class="comment">//这里配置了dubbo的application信息*(demo只配置了name)*，因此demo没有额外的dubbo.xml配置文件</span></span><br><span class="line">        RegistryConfig registryConfig = <span class="keyword">new</span> RegistryConfig();</span><br><span class="line">        registryConfig.setAddress(prop.getProperty(<span class="string">"registry.address"</span>)); </span><br><span class="line">        <span class="comment">//这里配置dubbo的注册中心信息，因此demo没有额外的dubbo.xml配置文件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.application = applicationConfig;</span><br><span class="line">        <span class="keyword">this</span>.registry = registryConfig;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DubboServiceFactory <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">genericInvoke</span><span class="params">(String interfaceClass, String methodName, List&lt;Map&lt;String, Object&gt;&gt; parameters)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        ReferenceConfig&lt;GenericService&gt; reference = <span class="keyword">new</span> ReferenceConfig&lt;GenericService&gt;();</span><br><span class="line">        reference.setApplication(application); </span><br><span class="line">        reference.setRegistry(registry); </span><br><span class="line">        reference.setInterface(interfaceClass); <span class="comment">// 接口名 </span></span><br><span class="line">        reference.setGeneric(<span class="keyword">true</span>); <span class="comment">// 声明为泛化接口 </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//ReferenceConfig实例很重，封装了与注册中心的连接以及与提供者的连接，</span></span><br><span class="line">        <span class="comment">//需要缓存，否则重复生成ReferenceConfig可能造成性能问题并且会有内存和连接泄漏。</span></span><br><span class="line">        <span class="comment">//API方式编程时，容易忽略此问题。</span></span><br><span class="line">        <span class="comment">//这里使用dubbo内置的简单缓存工具类进行缓存</span></span><br><span class="line">        </span><br><span class="line">        ReferenceConfigCache cache = ReferenceConfigCache.getCache();</span><br><span class="line">        GenericService genericService = cache.get(reference); </span><br><span class="line">        <span class="comment">// 用com.alibaba.dubbo.rpc.service.GenericService可以替代所有接口引用 </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = parameters.size();</span><br><span class="line">        String[] invokeParamTyeps = <span class="keyword">new</span> String[len];</span><br><span class="line">        Object[] invokeParams = <span class="keyword">new</span> Object[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            invokeParamTyeps[i] = parameters.get(i).get(<span class="string">"ParamType"</span>) + <span class="string">""</span>;</span><br><span class="line">            invokeParams[i] = parameters.get(i).get(<span class="string">"Object"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> genericService.$invoke(methodName, invokeParamTyeps, invokeParams);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="七-部署"><a href="#七-部署" class="headerlink" title="七.部署"></a>七.部署</h2><p>将Router部署到Jetty/Tomcat等容器，或者直接使用<a href="http://projects.spring.io/spring-boot/" target="_blank" rel="external">SpringBoot</a>开发，发布为内嵌Jetty/Tomcat的独立jar包，即可向前端服务提供服务。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JMeter性能测试3.0时代之-全新JMeter插件管理]]></title>
      <url>http://walbx.github.io/2016/07/05/JMeter%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%953-0%E6%97%B6%E4%BB%A3%E4%B9%8B-%E5%85%A8%E6%96%B0JMeter%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<blockquote>
<p>今年五月，老牌开源性能测试工具<a href="http://jmeter.apache.org/" target="_blank" rel="external">Apache JMeter</a>迎来了自2011年11月成为Apache顶级项目以来的首次大版本更新–从2.13更新到3.0。<br>这对于广大JMeter用户来说无疑是一个好消息，它让我们看到了这个项目的活力。也是因此，打算写一些自己感受到的JMeter近来的变化。</p>
</blockquote>
<a id="more"></a>
<h2 id="JMeter"><a href="#JMeter" class="headerlink" title="JMeter"></a>JMeter</h2><p><a href="http://jmeter.apache.org/" target="_blank" rel="external">JMeter</a>，老牌，开源，轻量，Apache基金会的顶级项目，光是这些关键字就足以让大量用户将其纳入自己的性能测试工具箱。而从实际看来，其在国内的用户数量，足以和著名的LoadRunner分庭抗礼，甚至在如今的互联网浪潮下，其覆盖范围可能已经超越了LR，甚至在其他领域，如接口测试，也能看到JMeter的身影。对于这样的发展趋势，我也非常乐意看到，因为我最初做性能测试时，选择了使用JMeter作为主力工具。</p>
<p>然而最近两年，JMeter并没有太多值得关注的更新。虽然现在的我已经不再是性能测试的萌新，不会被一个工具所制约，但是作为帮助我入门的工具，还是希望能够看到一个更活跃的JMeter，更活跃的JMeter生态。</p>
<p>今年夏天，首先得到的好消息是JMeter迎来了它的3.0版本，其中一个重要的更新就是HTML页面形式的性能测试报告，这一方面它终于是赶上了<a href="http://gatling.io/#/" target="_blank" rel="external">Gatling</a>(<em>关注Gatling主要因为两方面：一是其甩JMeter几条街的性能，二就是其出色的report</em>)。</p>
<p>然而今天这篇文章并不是讲JMeter 3.0的新特性(<em>废话半天竟然又不讲这，我自己都醉了。主要是由于时间不够，3.0的新特性，计划放到下一篇文章</em>)，今天要提的是第二个消息，不是来自于JMeter自身，而是<strong>JMeter Plugins</strong>。</p>
<h2 id="JMeter-Plugins"><a href="#JMeter-Plugins" class="headerlink" title="JMeter Plugins"></a>JMeter Plugins</h2><p>一直以来，<a href="http://www.jmeter-plugins.org/" target="_blank" rel="external">JMeter Plugins</a>为我们提供了很多高价值的JMeter插件，比如:</p>
<ul>
<li>用于服务器性能监视的<a href="http://jmeter-plugins.org/wiki/PerfMon" target="_blank" rel="external">PerfMon Metrics Collector</a></li>
<li>用于建立压力变化模型的<a href="http://jmeter-plugins.org/wiki/SteppingThreadGroup" target="_blank" rel="external">Stepping Thread Group</a></li>
<li>用于Json解析的<a href="http://jmeter-plugins.org/wiki/JSONPathExtractor" target="_blank" rel="external">JSON Path Extractor</a></li>
<li>用于展示响应时间曲线的<a href="http://jmeter-plugins.org/wiki/ResponseTimesOverTime" target="_blank" rel="external">Response Times Over Time</a></li>
<li>用于展示TPS曲线的<a href="http://jmeter-plugins.org/wiki/TransactionsPerSecond" target="_blank" rel="external">Transactions per Second</a><br>非常感谢这些插件的贡献者很大程度上丰富了JMeter的生态，并直接造福了广大的JMeter使用者。</li>
</ul>
<p>在以前，这些插件的安装还是一个纯手工的方式：所有插件分为四个集合包，首先需要找到包含目标功能的集合包-下载该依赖包-拷贝的合适的路径-重启JMeter。这样的过程对于刚接触JMeter的新人来说，可能稍显繁琐。</p>
<h2 id="Plugins-Manager"><a href="#Plugins-Manager" class="headerlink" title="Plugins Manager"></a>Plugins Manager</h2><p>值得高兴的是，最近，<strong>jmeter-plugins.org</strong>推出了全新的<a href="http://www.jmeter-plugins.org/wiki/PluginsManager/" target="_blank" rel="external">Plugins Manager</a>，对于其提供的插件进行了集中的管理，我们只需要安装这个管理插件，即可以在JMeter的界面上搜索并安装指定的插件。简要步骤如下：</p>
<ol>
<li>下载管理插件的<a href="http://jmeter-plugins.org/get/" target="_blank" rel="external">JAR文件</a></li>
<li>将下载的文件拷贝的你的JMeter根目录下的<code>lib/ext</code>目录</li>
<li>启动JMeter，点击<code>菜单栏</code>-<code>Options</code>-<code>Plugins Manager</code>,如<code>图1</code>：</li>
</ol>
<p><img src="http://ww1.sinaimg.cn/large/9bd9d3e2gw1f5otxp1yk8j20c908675n.jpg" alt="图1"></p>
<ol>
<li>在如<code>图2</code>的管理页面进行插件管理，共有三个标签页:</li>
</ol>
<p><img src="http://ww2.sinaimg.cn/large/9bd9d3e2gw1f5otxpd97mj20hr07qjtn.jpg" alt="图2"></p>
<ul>
<li>Installed Plugins：顾名思义，是用于查看已安装的插件，并可通过<code>取消勾选</code>-<code>应用操作</code>来卸载插件</li>
<li>Available Plugins:用于查看和安装可用的插件</li>
<li>Upgrades:用于升级插件</li>
</ul>
<p>另外，Plugins Manager还提供了命令行安装的支持，具体参见<a href="http://jmeter-plugins.org/wiki/PluginsManager/" target="_blank" rel="external">官方wiki</a>，以便让在Linux上或者以NO-GUI方式在windows运行的使用者也能快捷的进行JMeter插件管理。</p>
<p>最后，快快去体验一下吧 : )</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[正确、安全地停止SpringBoot应用]]></title>
      <url>http://walbx.github.io/2016/06/27/%E6%AD%A3%E7%A1%AE%E3%80%81%E5%AE%89%E5%85%A8%E5%9C%B0SpringBoot%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/large/9bd9d3e2gw1f5bxlcc3o9j20nz0b7t8t.jpg" alt=""></p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><a href="http://projects.spring.io/spring-boot/" target="_blank" rel="external">Spring Boot</a>，作为Spring框架对“约定优先于配置(Convention Over Configuration)”理念的最佳实践的产物，它能帮助我们很快捷的创建出独立运行、产品级别的基于Spring框架的应用，大部分Spring Boot应用只需要非常少的配置就可以快速运行起来，是一个与微服务(MicroServices)相当契合的微框架。<br>网络上关于Spring Boot的QuickStart式中文内容已经相当丰富，但是对于部署后怎样便捷、安全地停止服务(shutdown)，还比较缺乏，最近发现Spring Boot的官方指南更新了相关内容，因此结合该部分更新，对如何<strong>基于官方提供的特性</strong>正确地停止Spring Boot应用进行简单说明。</p>
<p>主要有两种方式：通过<code>HTTP</code>发送<code>shutdown</code>信号，或者通过<code>service stop</code>的方式<br><a id="more"></a></p>
<h2 id="方式一：通过HTTP发送shutdown信号"><a href="#方式一：通过HTTP发送shutdown信号" class="headerlink" title="方式一：通过HTTP发送shutdown信号"></a>方式一：通过<code>HTTP</code>发送<code>shutdown</code>信号</h2><p>该方式主要依赖<code>Spring Boot Actuator</code>的<code>endpoint</code>特性，具体步骤如下：</p>
<h3 id="1-在pom-xml中引入actuator依赖"><a href="#1-在pom-xml中引入actuator依赖" class="headerlink" title="1. 在pom.xml中引入actuator依赖"></a>1. 在<code>pom.xml</code>中引入<code>actuator</code>依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-开启shutdown-endpoint"><a href="#2-开启shutdown-endpoint" class="headerlink" title="2. 开启shutdown endpoint"></a>2. 开启<code>shutdown endpoint</code></h3><p>  <code>Spring Boot Actuator</code>的<code>shutdown endpoin</code>t默认是关闭的，因此在<code>application.properties</code>中开启<code>shutdown endpoint</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#启用shutdown</span><br><span class="line">endpoints.shutdown.enabled=true</span><br><span class="line">#禁用密码验证</span><br><span class="line">endpoints.shutdown.sensitive=false</span><br></pre></td></tr></table></figure></p>
<h3 id="3-发送shutdown信号"><a href="#3-发送shutdown信号" class="headerlink" title="3. 发送shutdown信号"></a>3. 发送<code>shutdown</code>信号</h3><p>  <code>shutdown</code>的默认<code>url</code>为<code>host:port/shutdown</code>，当需要停止服务时，向服务器<code>post</code>该请求即可，如：<br><code>curl -X POST host:port/shutdown</code><br>将得到形如<code>{&quot;message&quot;:&quot;Shutting down, bye...&quot;}</code>的响应</p>
<h3 id="4-安全设置"><a href="#4-安全设置" class="headerlink" title="4. 安全设置"></a>4. 安全设置</h3><p>可以看出，使用该方法可以非常方便的进行远程操作，但是需要注意的是，正式使用时，必须对该请求进行必要的安全设置，比如借助<code>spring-boot-starter-security</code>进行身份认证：</p>
<ol>
<li><p>pom.xml添加security依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启安全验证<br>在<code>application.properties</code>中变更配置,并</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#开启shutdown的安全验证</span><br><span class="line">endpoints.shutdown.sensitive=true</span><br><span class="line">#验证用户名</span><br><span class="line">security.user.name=admin</span><br><span class="line">#验证密码</span><br><span class="line">security.user.password=secret</span><br><span class="line">#角色</span><br><span class="line">management.security.role=SUPERUSER</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定路径、IP、端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#指定shutdown endpoint的路径</span><br><span class="line">endpoints.shutdown.path=/custompath</span><br><span class="line">#也可以统一指定所有endpoints的路径`management.context-path=/manage`</span><br><span class="line">#指定管理端口和IP</span><br><span class="line">management.port=8081</span><br><span class="line">management.address=127.0.0.1</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="方式二：部署为Unix-Linux-Service"><a href="#方式二：部署为Unix-Linux-Service" class="headerlink" title="方式二：部署为Unix/Linux Service"></a>方式二：部署为Unix/Linux Service</h2><p>该方式主要借助官方的<code>spring-boot-maven-plugin</code>创建”Fully executable” jar ，这中jar包内置一个shell脚本，可以方便的将该应用设置为Unix/Linux的系统服务(init.d service),官方对该功能在CentOS和Ubuntu进行了测试，对于OS X和FreeBSD,可能需要自定义。具体步骤如下:</p>
<h3 id="1-在pom-xml中引入插件："><a href="#1-在pom-xml中引入插件：" class="headerlink" title="1. 在pom.xml中引入插件："></a>1. 在<code>pom.xml</code>中引入插件：</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">  &lt;configuration&gt;</span><br><span class="line">    &lt;executable&gt;true&lt;/executable&gt;</span><br><span class="line">  &lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-设置为系统服务"><a href="#2-设置为系统服务" class="headerlink" title="2. 设置为系统服务"></a>2. 设置为系统服务</h3><p>  将你的应用打成jar包，部署到服务器，假设部署路径为/var/app，包名为app.jar，通过如下方式将应该设置为一个系统服务：<br><code>sudo ln -s /var/app/app.jar /etc/init.d/app</code></p>
<h3 id="3-赋予可执行权限："><a href="#3-赋予可执行权限：" class="headerlink" title="3. 赋予可执行权限："></a>3. 赋予可执行权限：</h3><p><code>chmod u+x app.jar</code></p>
<h3 id="4-以系统服务的方式管理"><a href="#4-以系统服务的方式管理" class="headerlink" title="4. 以系统服务的方式管理"></a>4. 以系统服务的方式管理</h3><p>  接下来，就可以使用我们熟悉的service foo start|stop|restart来对应用进行启停等管理了<br><code>sudo service app start|stop</code><br>命令将得到形如<code>Started|Stopped [PID]</code>的结果反馈</p>
<p>默认PID文件路径：/var/run/appname/appname.pid<br>默认日志文件路径：/var/log/appname.log</p>
<p>这可能是我们更熟悉也更常用的管理方式。</p>
<h3 id="自定义参数"><a href="#自定义参数" class="headerlink" title="自定义参数"></a>自定义参数</h3><p>在这种方式下，我们还可以使用自定义的.conf文件来变更默认配置，方法如下：</p>
<ol>
<li>在jar包相同路径下创建一个.conf文件，名称应该与.jar的名称相同，如appname.conf</li>
<li>在其中配置相关变量，如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=/usr/local/jdk</span><br><span class="line">JAVA_OPTS=-Xmx1024M</span><br><span class="line">LOG_FOLDER=/custom/log</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="安全设置"><a href="#安全设置" class="headerlink" title="安全设置"></a>安全设置</h3><p>作为应用服务，安全性是一个不能忽略的问题，如下一些操作可以作为部分基础设置参考：</p>
<ul>
<li>为服务创建一个独立的用户，同时最好将该用户的shell绑定为/usr/sbin/nologin</li>
<li>赋予最小范围权限：<code>chmod 500 app.jar</code></li>
<li>阻止修改：<code>sudo chattr +i app.jar</code></li>
<li>对.conf文件做类似的工作：<code>chmod 400 app.conf</code>,<code>sudo chown root:root app.conf</code></li>
</ul>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li><a href="http://docs.spring.io/spring-boot/docs/current/reference/html/deployment-install.html" target="_blank" rel="external">Installing Spring Boot applications</a></li>
<li><a href="http://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-enabling.html" target="_blank" rel="external">Endpoints</a></li>
<li><a href="http://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-monitoring.html#production-ready-sensitive-endpoints" target="_blank" rel="external">Securing sensitive endpoints</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Welcome]]></title>
      <url>http://walbx.github.io/2016/06/21/FirstPost/</url>
      <content type="html"><![CDATA[<p>  Welcome to my blog, it is under construction.</p>
]]></content>
    </entry>
    
  
  
</search>
